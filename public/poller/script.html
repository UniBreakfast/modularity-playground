<script>

const requestDelay = 1000
const handleDelay = 1000
const handleTimeout = 4*60*1000
const requestTimeout = 1*60*1000

const polls = []


class Poller extends EventTarget {
  constructor (name, requestFn) {
    super()
    this.id = generateId()
    this.name = name
    this.listen(requestFn)
  }

  async listen(requestFn) {
    while (true) {
      const answers = await requestFn(this.id, this.name)
      if (answers?.length)
        this.dispatchEvent(new CustomEvent('message', {detail: answers}))
    }
  }
}

const poller1 = new Poller('Bob', request)
const poller2 = new Poller('Alex', request)



poller1.addEventListener('message', msg => {
  msg.detail.forEach(message => document.body.innerHTML += `
    <p style="color: green">${message}</p>
  `)
})
poller2.addEventListener('message', msg => {
  msg.detail.forEach(message => document.body.innerHTML += `
    <p style="color: brown">${message}</p>
  `)
})


class Poll {
  constructor () {
    polls.push(this)
  }

  update(props) {
    Object.assign(this, props)
  }

  keep(...messages) {
    if (!messages.length) return
    if (this.messages) this.messages.push(...messages)
    else this.messages = messages
  }

  send(...messages) {
    this.resp.end(prepare(messages))
    delete this.resp
    clearTimeout(this.timer)
    this.waitForRequest()
  }

  sendTo(resp) {
    resp.end(prepare(this.messages))
    delete this.messages
    clearTimeout(this.timer)
    this.waitForRequest()
  }

  waitForRequest() {
    this.timer = setTimeout(() => {
      polls.splice(polls.indexOf(this), 1)
    }, requestTimeout)
  }

  waitForUpdate(resp) {
    this.resp = resp
    this.timer = setTimeout(() => {
      this.send()
    }, handleTimeout)
  }
}

function prepare(obj) {
  return obj
  return JSON.stringify(obj)
}

async function handle(req, resp) {
  await sleep(handleDelay)
  const props = extract(req)
  let poll = polls.find(poll => poll.id == props.id) || new Poll
  poll.update(props)

  if (poll.messages) poll.sendTo(resp)
  else poll.waitForUpdate(resp)
}


async function request(id, name) {
  await sleep(requestDelay)
  return new Promise(resolve => handle({id, name}, {end: resolve}))
}

function message(...messages) {
  return function messageTo(poll) {
    if (!poll) return
    if (poll.resp) poll.send(...messages)
    else poll.keep(...messages)
  }
}

function broadcast(msg, skipId) {
  if (skipId) polls.filter(poll => poll.id != skipId).forEach(message(msg))
  else polls.forEach(message(msg))
}

function inform(msg, predicate, ...props) {
  polls.filter(predicate, props).forEach(message(msg))
}

function informUser(msg, ...names) {
  inform(msg, poll => names.includes(poll.name))
}
function informClient(msg, ...ids) {
  inform(msg, poll => ids.includes(poll.id))
}


function generateId() {
  const chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'
  const {random} = Math

  let token = ''
  for (let i = 0; i < 13; ++i)
    token += (i+1)%7 ? chars[random() * 62 | 0] : '-'
  return token
}

function sleep(duration) {
  return new Promise(resolve => setTimeout(resolve, duration))
}

function extract({id, name}) {
  return {id, name}
}

</script><link rel="icon" href="data:;base64,iVBORw0KGgo=">
